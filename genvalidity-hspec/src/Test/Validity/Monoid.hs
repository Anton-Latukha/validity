{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE AllowAmbiguousTypes #-}

-- | Monoid properties
--
-- You will need @TypeApplications@ to use these.
module Test.Validity.Monoid
    ( monoidSpecOnValid
    , monoidSpec
    , monoidSpecOnArbitrary
    , monoidSpecOnGen
    ) where

import Data.Data

import Data.GenValidity

import Test.Hspec
import Test.QuickCheck

import Test.Validity.Functions
import Test.Validity.Operations
import Test.Validity.Relations
import Test.Validity.Utils

memptyTypeStr
    :: forall a.
       Typeable a
    => String
memptyTypeStr = unwords ["mempty", "::", nameOf @a]

mappendTypeStr
    :: forall a.
       Typeable a
    => String
mappendTypeStr = unwords ["mappend", "::", an, "->", an, "->", an]
  where
    an = nameOf @a

mconcatTypeStr
    :: forall a.
       Typeable a
    => String
mconcatTypeStr = unwords ["mconcat", "::", "[" ++ an ++ "]", "->", an]
  where
    an = nameOf @a

-- | Standard test spec for properties of 'Monoid' instances for valid values
--
-- Example usage:
--
-- > monoidSpecOnValid @[Double]
monoidSpecOnValid
    :: forall a.
       (Show a, Eq a, Monoid a, Typeable a, GenValid a)
    => Spec
monoidSpecOnValid = monoidSpecOnGen @a genValid "valid"

-- | Standard test spec for properties of 'Monoid' instances for unchecked values
--
-- Example usage:
--
-- > monoidSpec @[Int]
monoidSpec
    :: forall a.
       (Show a, Eq a, Monoid a, Typeable a, GenUnchecked a)
    => Spec
monoidSpec = monoidSpecOnGen @a genUnchecked "unchecked"

-- | Standard test spec for properties of 'Monoid' instances for arbitrary values
--
-- Example usage:
--
-- > monoidSpecOnArbitrary @[Int]
monoidSpecOnArbitrary
    :: forall a.
       (Show a, Eq a, Monoid a, Typeable a, Arbitrary a)
    => Spec
monoidSpecOnArbitrary = monoidSpecOnGen @a arbitrary "arbitrary"

-- | Standard test spec for properties of Monoid instances for values generated by a given generator (and name for that generator).
--
-- Example usage:
--
-- > monoidSpecOnGen (pure "a") "singleton list of 'a'"
monoidSpecOnGen
    :: forall a.
       (Show a, Eq a, Monoid a, Typeable a)
    => Gen a -> String -> Spec
monoidSpecOnGen gen genname =
    parallel $ do
        let name = nameOf @a
            memptystr = memptyTypeStr @a
            mappendstr = mappendTypeStr @a
            mconcatstr = mconcatTypeStr @a
            gen3 = (,,) <$> gen <*> gen <*> gen
            genl = genListOf gen
        describe ("Monoid " ++ name) $ do
            let mem = mempty @a
                mapp = mappend @a
                mcon = mconcat @a
            describe memptystr $
                it (unwords ["is the identity for", mappendstr]) $
                identityOnGen mapp mem gen
            describe mappendstr $
                it "is an associative operation" $ associativeOnGens mapp gen3
            describe mconcatstr $
                it "is equivalent to its default implementation" $
                equivalentOnGen mcon (foldr mapp mem) genl
