{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}

module Test.Syd.SydCheck.Eq
  ( eqSpec,
    eqSpecOnGen,
  )
where

import Data.Typeable
import SydCheck
import Test.Syd
import Test.Syd.SydCheck.Relations
import Test.Syd.SydCheck.Runner ()
import Test.Syd.SydCheck.Utils

eqSpec ::
  forall a.
  ( Show a,
    Eq a,
    Typeable a,
    GenValid a
  ) =>
  Spec
eqSpec = eqSpecOnGen @a genValid "valid"

-- | Standard test spec for properties of Eq instances for values generated by a given generator (and name for that generator).
--
-- Example usage:
--
-- > eqSpecOnGen ((* 2) <$> genValid @Int) "even"
eqSpecOnGen ::
  forall a.
  (Show a, Eq a, Typeable a) =>
  Gen a ->
  String ->
  Spec
eqSpecOnGen gen genname =
  parallel $ do
    let name = nameOf @a
        funeqstr = eqTypeStr @a
        funneqstr = neqTypeStr @a
        gen2 = (,) <$> gen <*> gen
        gen3 = (,,) <$> gen <*> gen <*> gen
    describe ("Eq " ++ name) $ do
      let eq = (==) @a
          neq = (/=) @a
      describe funeqstr $ do
        it
          ( unwords
              [ "is reflexive for",
                "\"" ++ genname,
                name ++ "\"" ++ "s"
              ]
          )
          $ reflexivityOnGen eq gen
        it
          ( unwords
              [ "is symmetric for",
                "\"" ++ genname,
                name ++ "\"" ++ "s"
              ]
          )
          $ symmetryOnGens eq gen2

        it
          ( unwords
              [ "is transitive for",
                "\"" ++ genname,
                name ++ "\"" ++ "s"
              ]
          )
          $ transitivityOnGens eq gen3

-- it
--   ( unwords
--       [ "is equivalent to (\\a b -> not $ a /= b) for",
--         "\"" ++ genname,
--         name ++ "\"" ++ "s"
--       ]
--   )
--   $ equivalentOnGens2 eq (\a b -> not $ a `neq` b) gen2 s2
-- describe funneqstr $ do
--  it
--    ( unwords
--        [ "is antireflexive for",
--          "\"" ++ genname,
--          name ++ "\"" ++ "s"
--        ]
--    )
--    $ antireflexivityOnGen neq gen s
--  it
--    ( unwords
--        [ "is equivalent to (\\a b -> not $ a == b) for",
--          "\"" ++ genname,
--          name ++ "\"" ++ "s"
--        ]
--    )
--    $ equivalentOnGens2 neq (\a b -> not $ a `eq` b) gen2 s2

eqTypeStr ::
  forall a.
  Typeable a =>
  String
eqTypeStr = binRelStr @a "=="

neqTypeStr ::
  forall a.
  Typeable a =>
  String
neqTypeStr = binRelStr @a "/="
